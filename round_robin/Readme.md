Имитация алгоритма распределения задач round robin с графическим интерфейсом.

Описание.

Графический интерфейс реализован с помощью библиотеки tkinter и запускается из файла interface.py. 

Интерфейс содержит 3 поля:
1) Список текущих исполнителей, задействованных в решениях задач с их производительностью и текущие задачи исполнителей с их сложностью.

2) Полный список задач выбранного исоплнителя. При клике на исполнителя из 1 окна, в этом окне отображается весь список задач исполнителя

3) Список выполненных задач. Если при завершении цикла какая-либо из задач была выполнена, в это окно заносится исполнитель, задача и цикл её завершения.

3 кнопки:

1) кнопка «New» Инициирует новую имитацию. Создается экземпляр класса RoundRobin, который генерирует новых исполнителей и задачи, распределяет задачи между исполнителями.

2) кнопка «Pause», которая останавливает время таймера и запускает его вновь.

3) кнопка «Settings», при нажатии на которую открывается отдельное окно с текущими настройками. Во время запуска интерфейса подгружаются стартовые настройки из файла start_settings.json. Для изменения необходимо ввести целое число в поле.

Так же интерфейс содержит ярлыки-подписи полей, секундомер таймера и отображение текущего раунда.

Описание работы алгоритма. 

При запуске интерфейса подгружаются стартовые настройки из файла start_settings.json.

После запуска нового раунда создается новый экземпляр класса RoundRobin, которому передается слепок существующих на момент запуска настроек. Поскольку функционалом не предусмотрена дополнительная генерация задач-исполнителей, возможность обновлять настройки класса RoundRobin не предусмотрена, только генерация нового экземпляра.

Класс RoundRobin запрашивает список исполнителей и список задач.

Генерацией списка исполнителей занимается класс ExecutorGenerator. При создании экземпляра класса задаются минимальная-максимальная продуктивность исполнителя.

При реализации метода get_executor_roster(number_of_names) на входе задается количество исполнителей. Имена программа получает с помощью открытого API от веб генератора фейковых имен. Если по каким-то причинам сайт окажется недоступен, то вместо имен будут сгенерированы заглушки вида «boy_name_1» и «girl_name_1».

Результатом будет список объектов класса Executor. Каждый из которых обладает характеристиками (name, productivity, task_queue) и методами позволяющими получить текущую задачу, находящуюся на исполнении, весь список задач исполнителя, его имя, продуктивность а так же выполнить текущую задачу.


Генерацией списка задач занимается класс TaskGenerator. В нем реализован немного другой подход и задачи просто собираются из некоторого множества наречий, глаголов и существительных в предложения вида «Быстро взломать сейф». В случае, если имя дублируется, к имени добавляется порядковый номер _2, _3 и т. д.

 Результатом будет список объектов класса Task, обладающих характеристиками name, complexity и методами, позволяющими получить имя-текущую сложность задачи, понизить текущую сложность задачи (на продуктивность исполнителя) и проверить выполнена ли эта задача.

После получения задач и исполнителей класс RoundRobin распределяет задачи и ждет команды для запуска следующего круга (метод new_round()). 

При запуске нового раунда:
каждый исполнитель отнимает от сложности текущей задачи свою продуктивность и проверяет выполнена ли задача. 

Если задача выполнена, она исключается из очереди задач исполнителя и заносится в список выполненных на этом раунде задач. 

После того как каждый исполнитель проверил все свои текущие задачи с 50% вероятностью начинается обмен текущими задачами между исполнителями.

Результатом этого метода становится словарь, содержащий информацию о выполненных исполнителями задачами в текущем раунде, которая будет использована для заполнения таблиц интерфейса.
